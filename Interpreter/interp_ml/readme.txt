Crispin Bernier
chb2ab
pa5

	I implemented the interpreter in OCaml because I thought it would make the assignment easier. The first step in my implementation was deserializing the class map, implementation map, and parent map from the type file. I did not deserialize the annotated abstract syntax tree because it was not necessary. The class map is stored as a mapping from class name to a list of attributes for that class, where an attribute is a custom data type that can optionally have an initializer expression. The implementation map is represented as a mapping from class name to a mapping of method name to a custom method type that contains a list of formal names, the class that defines the method, and an expression for the method body. The parent map is represented as a mapping from a class name to it's parent. The expression type is a custom type that represents all possible Cool expressions such as let, dispatch, and new. Expression types contain all the information needed to execute that expression including any sub expressions that must also be executed. The deserialization code is contained in the getMaps.ml file.

	After reading in the maps the next step was to write a method that takes in a self object, environment, and an expression to execute, and executes that expression. Execution also requires the store, which is stored as a global variable in the program. I will now describe how the let, dispatch, and new expressions are executed, and the remaining expressions are executed similarly. Let expressions are executed recursively by executing the first variable binding in the let expression and then recursively evaluating the expression without the first binding until there are no more bindings, at which point the body of the let is evaluated. A let binding is executed by executing the initializer or creating a default object if there is no initializer, then generating a new register and binding that register to this new object in the store, and finally binding the identifier to the new register in the environment. When the body is executed the environment will have all the necessary let bindings to execute it.

	The first step to execute dispatch is to execute each of the parameters and generate new registers to hold each of the results in the store. The next step is to evaluate the dispatch object expression, in self dispatch this step is skipped because the dispatch object is just the self object. The last step is to execute the actual method, which is done by looking up the method in the implementation map using the class type of the dispatch object and the method name. In static dispatch the declared type is used in the lookup instead of the type of the dispatch object. Then a new environment is created where the formal parameters for the method map to the parameters that were just evaluated and the dispatch objects attributes are also added to the new environment but they are overshadowed by the formals. Finally the method body is executed with the dispatch object as the self object and with the new environment. Dispatch also includes checks for stack overflow and for dispatches on void, both of which result in exceptions.

	One other type of expression is new type. New is handled by first checking if the type is a String, Int, or Bool in which case there is a predefined default object to return. If this is not the case then the type is looked up in the class map to get a list of attributes, if the type is SELF_TYPE then the type of the self object is looked up instead. A new environment and store is then created that maps each of the attributes to the default for that attributes type, and a new object is created that contains these attributes. The attributes are iterated over again and the attribute initializers are executed with the new object as the self object and the new environment that has all the attributes in it, and the store is updated with the results. After initializing the attributes the execution is finished and the new object is returned. Executing an entire cool program is done by generating a new Main object and dispatching the main method on that object with no parameters.

	I tested my interpreter on many Cool programs, totaling around a few hundred test cases. Most of my tests use string and integer output functions to compare against the reference compiler, and I also made shell scripts to automatically run tests and do diff comparisons on the output for the reference interpreter. test1.cl is one example test case which tests accessing class attributes, performs a case expression on a number of different objects, and also tests the scoping of the case identifier. This testcase ends on a case on void error to test for error reporting. test2.cl deals with dispatches. This testcase calls overwritten methods, checks the order parameters are evaluated, and includes self dispatches, dynamic dispatches, static dispatches, and a dispatch on void. test3.cl tests arithmetic evaluation, conditional statement evaluations, loops, and the internal abort method. test4.cl checks proper input and output of strings, especially predefined strings with strange characters like escaped quotes and newlines. This testcase has all the different types of dispatch and also tests internal methods such as type_name, substr, concat, length, out_int, and out_string, as well as their return types. The last statement in this testcase is an error call to the substr internal method. I had some difficulty with implementing strings and test4.cl helped me debug these corner cases for strings. The diff command and shell scripts were used for automatically testing all my test cases. PA5t was also very helpful for getting a good set of test cases.