Created by PLY version 3.7 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> CLASS semi
Rule 2     PROGRAM -> PROGRAM CLASS semi
Rule 3     CLASS -> class type inherits type lbrace FEATUREPLUS rbrace
Rule 4     CLASS -> class type inherits type lbrace rbrace
Rule 5     CLASS -> class type lbrace FEATUREPLUS rbrace
Rule 6     CLASS -> class type lbrace rbrace
Rule 7     FEATURE -> identifier lparen FORMALPLUS rparen colon type lbrace EXPR rbrace
Rule 8     FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace
Rule 9     FEATURE -> identifier colon type
Rule 10    FEATURE -> identifier colon type larrow EXPR
Rule 11    FORMAL -> identifier colon type
Rule 12    EXPR -> identifier larrow EXPR
Rule 13    EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen
Rule 14    EXPR -> EXPR at type dot identifier lparen rparen
Rule 15    EXPR -> EXPR dot identifier lparen EXPRPLUS rparen
Rule 16    EXPR -> EXPR dot identifier lparen rparen
Rule 17    EXPR -> identifier lparen EXPRPLUS rparen
Rule 18    EXPR -> identifier lparen rparen
Rule 19    EXPR -> if EXPR then EXPR else EXPR fi
Rule 20    EXPR -> while EXPR loop EXPR pool
Rule 21    EXPR -> lbrace EXPRSEMIPLUS rbrace
Rule 22    EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
Rule 23    EXPR -> let identifier colon type larrow EXPR in EXPR
Rule 24    EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR
Rule 25    EXPR -> let identifier colon type in EXPR
Rule 26    EXPR -> case EXPR of IDTYPEARROWPLUS esac
Rule 27    EXPR -> new type
Rule 28    EXPR -> isvoid EXPR
Rule 29    EXPR -> EXPR plus EXPR
Rule 30    EXPR -> EXPR minus EXPR
Rule 31    EXPR -> EXPR times EXPR
Rule 32    EXPR -> EXPR divide EXPR
Rule 33    EXPR -> tilde EXPR
Rule 34    EXPR -> EXPR lt EXPR
Rule 35    EXPR -> EXPR le EXPR
Rule 36    EXPR -> EXPR equals EXPR
Rule 37    EXPR -> not EXPR
Rule 38    EXPR -> lparen EXPR rparen
Rule 39    EXPR -> identifier
Rule 40    EXPR -> integer
Rule 41    EXPR -> string
Rule 42    EXPR -> true
Rule 43    EXPR -> false
Rule 44    FEATUREPLUS -> FEATURE semi
Rule 45    FEATUREPLUS -> FEATUREPLUS FEATURE semi
Rule 46    FORMALPLUS -> FORMAL
Rule 47    FORMALPLUS -> FORMALPLUS comma FORMAL
Rule 48    EXPRPLUS -> EXPR
Rule 49    EXPRPLUS -> EXPRPLUS comma EXPR
Rule 50    EXPRSEMIPLUS -> EXPR semi
Rule 51    EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi
Rule 52    IDTYPEEXPRPLUS -> comma identifier colon type larrow EXPR
Rule 53    IDTYPEEXPRPLUS -> comma identifier colon type
Rule 54    IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon type larrow EXPR
Rule 55    IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon type
Rule 56    IDTYPEARROWPLUS -> identifier colon type rarrow EXPR semi
Rule 57    IDTYPEARROWPLUS -> IDTYPEARROWPLUS identifier colon type rarrow EXPR semi

Terminals, with rules where they appear

at                   : 13 14
case                 : 26
class                : 3 4 5 6
colon                : 7 8 9 10 11 22 23 24 25 52 53 54 55 56 57
comma                : 47 49 52 53 54 55
divide               : 32
dot                  : 13 14 15 16
else                 : 19
equals               : 36
error                : 
esac                 : 26
false                : 43
fi                   : 19
identifier           : 7 8 9 10 11 12 13 14 15 16 17 18 22 23 24 25 39 52 53 54 55 56 57
if                   : 19
in                   : 22 23 24 25
inherits             : 3 4
integer              : 40
isvoid               : 28
larrow               : 10 12 22 23 52 54
lbrace               : 3 4 5 6 7 8 21
le                   : 35
let                  : 22 23 24 25
loop                 : 20
lparen               : 7 8 13 14 15 16 17 18 38
lt                   : 34
minus                : 30
new                  : 27
not                  : 37
of                   : 26
plus                 : 29
pool                 : 20
rarrow               : 56 57
rbrace               : 3 4 5 6 7 8 21
rparen               : 7 8 13 14 15 16 17 18 38
semi                 : 1 2 44 45 50 51 56 57
string               : 41
then                 : 19
tilde                : 33
times                : 31
true                 : 42
type                 : 3 3 4 4 5 6 7 8 9 10 11 13 14 22 23 24 25 27 52 53 54 55 56 57
while                : 20

Nonterminals, with rules where they appear

CLASS                : 1 2
EXPR                 : 7 8 10 12 13 14 15 16 19 19 19 20 20 22 22 23 23 24 25 26 28 29 29 30 30 31 31 32 32 33 34 34 35 35 36 36 37 38 48 49 50 51 52 54 56 57
EXPRPLUS             : 13 15 17 49
EXPRSEMIPLUS         : 21 51
FEATURE              : 44 45
FEATUREPLUS          : 3 5 45
FORMAL               : 46 47
FORMALPLUS           : 7 47
IDTYPEARROWPLUS      : 26 57
IDTYPEEXPRPLUS       : 22 24 54 55
PROGRAM              : 2 0

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . CLASS semi
    (2) PROGRAM -> . PROGRAM CLASS semi
    (3) CLASS -> . class type inherits type lbrace FEATUREPLUS rbrace
    (4) CLASS -> . class type inherits type lbrace rbrace
    (5) CLASS -> . class type lbrace FEATUREPLUS rbrace
    (6) CLASS -> . class type lbrace rbrace

    class           shift and go to state 1

    PROGRAM                        shift and go to state 2
    CLASS                          shift and go to state 3

state 1

    (3) CLASS -> class . type inherits type lbrace FEATUREPLUS rbrace
    (4) CLASS -> class . type inherits type lbrace rbrace
    (5) CLASS -> class . type lbrace FEATUREPLUS rbrace
    (6) CLASS -> class . type lbrace rbrace

    type            shift and go to state 4


state 2

    (0) S' -> PROGRAM .
    (2) PROGRAM -> PROGRAM . CLASS semi
    (3) CLASS -> . class type inherits type lbrace FEATUREPLUS rbrace
    (4) CLASS -> . class type inherits type lbrace rbrace
    (5) CLASS -> . class type lbrace FEATUREPLUS rbrace
    (6) CLASS -> . class type lbrace rbrace

    class           shift and go to state 1

    CLASS                          shift and go to state 5

state 3

    (1) PROGRAM -> CLASS . semi

    semi            shift and go to state 6


state 4

    (3) CLASS -> class type . inherits type lbrace FEATUREPLUS rbrace
    (4) CLASS -> class type . inherits type lbrace rbrace
    (5) CLASS -> class type . lbrace FEATUREPLUS rbrace
    (6) CLASS -> class type . lbrace rbrace

    inherits        shift and go to state 7
    lbrace          shift and go to state 8


state 5

    (2) PROGRAM -> PROGRAM CLASS . semi

    semi            shift and go to state 9


state 6

    (1) PROGRAM -> CLASS semi .

    class           reduce using rule 1 (PROGRAM -> CLASS semi .)
    $end            reduce using rule 1 (PROGRAM -> CLASS semi .)


state 7

    (3) CLASS -> class type inherits . type lbrace FEATUREPLUS rbrace
    (4) CLASS -> class type inherits . type lbrace rbrace

    type            shift and go to state 10


state 8

    (5) CLASS -> class type lbrace . FEATUREPLUS rbrace
    (6) CLASS -> class type lbrace . rbrace
    (44) FEATUREPLUS -> . FEATURE semi
    (45) FEATUREPLUS -> . FEATUREPLUS FEATURE semi
    (7) FEATURE -> . identifier lparen FORMALPLUS rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR

    rbrace          shift and go to state 11
    identifier      shift and go to state 14

    FEATUREPLUS                    shift and go to state 13
    FEATURE                        shift and go to state 12

state 9

    (2) PROGRAM -> PROGRAM CLASS semi .

    class           reduce using rule 2 (PROGRAM -> PROGRAM CLASS semi .)
    $end            reduce using rule 2 (PROGRAM -> PROGRAM CLASS semi .)


state 10

    (3) CLASS -> class type inherits type . lbrace FEATUREPLUS rbrace
    (4) CLASS -> class type inherits type . lbrace rbrace

    lbrace          shift and go to state 15


state 11

    (6) CLASS -> class type lbrace rbrace .

    semi            reduce using rule 6 (CLASS -> class type lbrace rbrace .)


state 12

    (44) FEATUREPLUS -> FEATURE . semi

    semi            shift and go to state 16


state 13

    (5) CLASS -> class type lbrace FEATUREPLUS . rbrace
    (45) FEATUREPLUS -> FEATUREPLUS . FEATURE semi
    (7) FEATURE -> . identifier lparen FORMALPLUS rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR

    rbrace          shift and go to state 17
    identifier      shift and go to state 14

    FEATURE                        shift and go to state 18

state 14

    (7) FEATURE -> identifier . lparen FORMALPLUS rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> identifier . lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> identifier . colon type
    (10) FEATURE -> identifier . colon type larrow EXPR

    lparen          shift and go to state 20
    colon           shift and go to state 19


state 15

    (3) CLASS -> class type inherits type lbrace . FEATUREPLUS rbrace
    (4) CLASS -> class type inherits type lbrace . rbrace
    (44) FEATUREPLUS -> . FEATURE semi
    (45) FEATUREPLUS -> . FEATUREPLUS FEATURE semi
    (7) FEATURE -> . identifier lparen FORMALPLUS rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR

    rbrace          shift and go to state 21
    identifier      shift and go to state 14

    FEATUREPLUS                    shift and go to state 22
    FEATURE                        shift and go to state 12

state 16

    (44) FEATUREPLUS -> FEATURE semi .

    rbrace          reduce using rule 44 (FEATUREPLUS -> FEATURE semi .)
    identifier      reduce using rule 44 (FEATUREPLUS -> FEATURE semi .)


state 17

    (5) CLASS -> class type lbrace FEATUREPLUS rbrace .

    semi            reduce using rule 5 (CLASS -> class type lbrace FEATUREPLUS rbrace .)


state 18

    (45) FEATUREPLUS -> FEATUREPLUS FEATURE . semi

    semi            shift and go to state 23


state 19

    (9) FEATURE -> identifier colon . type
    (10) FEATURE -> identifier colon . type larrow EXPR

    type            shift and go to state 24


state 20

    (7) FEATURE -> identifier lparen . FORMALPLUS rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> identifier lparen . rparen colon type lbrace EXPR rbrace
    (46) FORMALPLUS -> . FORMAL
    (47) FORMALPLUS -> . FORMALPLUS comma FORMAL
    (11) FORMAL -> . identifier colon type

    rparen          shift and go to state 25
    identifier      shift and go to state 27

    FORMAL                         shift and go to state 26
    FORMALPLUS                     shift and go to state 28

state 21

    (4) CLASS -> class type inherits type lbrace rbrace .

    semi            reduce using rule 4 (CLASS -> class type inherits type lbrace rbrace .)


state 22

    (3) CLASS -> class type inherits type lbrace FEATUREPLUS . rbrace
    (45) FEATUREPLUS -> FEATUREPLUS . FEATURE semi
    (7) FEATURE -> . identifier lparen FORMALPLUS rparen colon type lbrace EXPR rbrace
    (8) FEATURE -> . identifier lparen rparen colon type lbrace EXPR rbrace
    (9) FEATURE -> . identifier colon type
    (10) FEATURE -> . identifier colon type larrow EXPR

    rbrace          shift and go to state 29
    identifier      shift and go to state 14

    FEATURE                        shift and go to state 18

state 23

    (45) FEATUREPLUS -> FEATUREPLUS FEATURE semi .

    rbrace          reduce using rule 45 (FEATUREPLUS -> FEATUREPLUS FEATURE semi .)
    identifier      reduce using rule 45 (FEATUREPLUS -> FEATUREPLUS FEATURE semi .)


state 24

    (9) FEATURE -> identifier colon type .
    (10) FEATURE -> identifier colon type . larrow EXPR

    semi            reduce using rule 9 (FEATURE -> identifier colon type .)
    larrow          shift and go to state 30


state 25

    (8) FEATURE -> identifier lparen rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 31


state 26

    (46) FORMALPLUS -> FORMAL .

    rparen          reduce using rule 46 (FORMALPLUS -> FORMAL .)
    comma           reduce using rule 46 (FORMALPLUS -> FORMAL .)


state 27

    (11) FORMAL -> identifier . colon type

    colon           shift and go to state 32


state 28

    (7) FEATURE -> identifier lparen FORMALPLUS . rparen colon type lbrace EXPR rbrace
    (47) FORMALPLUS -> FORMALPLUS . comma FORMAL

    rparen          shift and go to state 33
    comma           shift and go to state 34


state 29

    (3) CLASS -> class type inherits type lbrace FEATUREPLUS rbrace .

    semi            reduce using rule 3 (CLASS -> class type inherits type lbrace FEATUREPLUS rbrace .)


state 30

    (10) FEATURE -> identifier colon type larrow . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 38

state 31

    (8) FEATURE -> identifier lparen rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 51


state 32

    (11) FORMAL -> identifier colon . type

    type            shift and go to state 52


state 33

    (7) FEATURE -> identifier lparen FORMALPLUS rparen . colon type lbrace EXPR rbrace

    colon           shift and go to state 53


state 34

    (47) FORMALPLUS -> FORMALPLUS comma . FORMAL
    (11) FORMAL -> . identifier colon type

    identifier      shift and go to state 27

    FORMAL                         shift and go to state 54

state 35

    (43) EXPR -> false .

    rbrace          reduce using rule 43 (EXPR -> false .)
    at              reduce using rule 43 (EXPR -> false .)
    dot             reduce using rule 43 (EXPR -> false .)
    plus            reduce using rule 43 (EXPR -> false .)
    minus           reduce using rule 43 (EXPR -> false .)
    times           reduce using rule 43 (EXPR -> false .)
    divide          reduce using rule 43 (EXPR -> false .)
    lt              reduce using rule 43 (EXPR -> false .)
    le              reduce using rule 43 (EXPR -> false .)
    equals          reduce using rule 43 (EXPR -> false .)
    semi            reduce using rule 43 (EXPR -> false .)
    then            reduce using rule 43 (EXPR -> false .)
    rparen          reduce using rule 43 (EXPR -> false .)
    of              reduce using rule 43 (EXPR -> false .)
    loop            reduce using rule 43 (EXPR -> false .)
    comma           reduce using rule 43 (EXPR -> false .)
    else            reduce using rule 43 (EXPR -> false .)
    pool            reduce using rule 43 (EXPR -> false .)
    fi              reduce using rule 43 (EXPR -> false .)
    in              reduce using rule 43 (EXPR -> false .)


state 36

    (19) EXPR -> if . EXPR then EXPR else EXPR fi
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 55

state 37

    (40) EXPR -> integer .

    rbrace          reduce using rule 40 (EXPR -> integer .)
    at              reduce using rule 40 (EXPR -> integer .)
    dot             reduce using rule 40 (EXPR -> integer .)
    plus            reduce using rule 40 (EXPR -> integer .)
    minus           reduce using rule 40 (EXPR -> integer .)
    times           reduce using rule 40 (EXPR -> integer .)
    divide          reduce using rule 40 (EXPR -> integer .)
    lt              reduce using rule 40 (EXPR -> integer .)
    le              reduce using rule 40 (EXPR -> integer .)
    equals          reduce using rule 40 (EXPR -> integer .)
    semi            reduce using rule 40 (EXPR -> integer .)
    then            reduce using rule 40 (EXPR -> integer .)
    rparen          reduce using rule 40 (EXPR -> integer .)
    of              reduce using rule 40 (EXPR -> integer .)
    loop            reduce using rule 40 (EXPR -> integer .)
    comma           reduce using rule 40 (EXPR -> integer .)
    else            reduce using rule 40 (EXPR -> integer .)
    pool            reduce using rule 40 (EXPR -> integer .)
    fi              reduce using rule 40 (EXPR -> integer .)
    in              reduce using rule 40 (EXPR -> integer .)


state 38

    (10) FEATURE -> identifier colon type larrow EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    semi            reduce using rule 10 (FEATURE -> identifier colon type larrow EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 39

    (28) EXPR -> isvoid . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 65

state 40

    (27) EXPR -> new . type

    type            shift and go to state 66


state 41

    (41) EXPR -> string .

    rbrace          reduce using rule 41 (EXPR -> string .)
    at              reduce using rule 41 (EXPR -> string .)
    dot             reduce using rule 41 (EXPR -> string .)
    plus            reduce using rule 41 (EXPR -> string .)
    minus           reduce using rule 41 (EXPR -> string .)
    times           reduce using rule 41 (EXPR -> string .)
    divide          reduce using rule 41 (EXPR -> string .)
    lt              reduce using rule 41 (EXPR -> string .)
    le              reduce using rule 41 (EXPR -> string .)
    equals          reduce using rule 41 (EXPR -> string .)
    semi            reduce using rule 41 (EXPR -> string .)
    then            reduce using rule 41 (EXPR -> string .)
    rparen          reduce using rule 41 (EXPR -> string .)
    of              reduce using rule 41 (EXPR -> string .)
    loop            reduce using rule 41 (EXPR -> string .)
    comma           reduce using rule 41 (EXPR -> string .)
    else            reduce using rule 41 (EXPR -> string .)
    pool            reduce using rule 41 (EXPR -> string .)
    fi              reduce using rule 41 (EXPR -> string .)
    in              reduce using rule 41 (EXPR -> string .)


state 42

    (22) EXPR -> let . identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> let . identifier colon type larrow EXPR in EXPR
    (24) EXPR -> let . identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> let . identifier colon type in EXPR

    identifier      shift and go to state 67


state 43

    (38) EXPR -> lparen . EXPR rparen
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 68

state 44

    (37) EXPR -> not . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 69

state 45

    (42) EXPR -> true .

    rbrace          reduce using rule 42 (EXPR -> true .)
    at              reduce using rule 42 (EXPR -> true .)
    dot             reduce using rule 42 (EXPR -> true .)
    plus            reduce using rule 42 (EXPR -> true .)
    minus           reduce using rule 42 (EXPR -> true .)
    times           reduce using rule 42 (EXPR -> true .)
    divide          reduce using rule 42 (EXPR -> true .)
    lt              reduce using rule 42 (EXPR -> true .)
    le              reduce using rule 42 (EXPR -> true .)
    equals          reduce using rule 42 (EXPR -> true .)
    semi            reduce using rule 42 (EXPR -> true .)
    then            reduce using rule 42 (EXPR -> true .)
    rparen          reduce using rule 42 (EXPR -> true .)
    of              reduce using rule 42 (EXPR -> true .)
    loop            reduce using rule 42 (EXPR -> true .)
    comma           reduce using rule 42 (EXPR -> true .)
    else            reduce using rule 42 (EXPR -> true .)
    pool            reduce using rule 42 (EXPR -> true .)
    fi              reduce using rule 42 (EXPR -> true .)
    in              reduce using rule 42 (EXPR -> true .)


state 46

    (26) EXPR -> case . EXPR of IDTYPEARROWPLUS esac
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 70

state 47

    (21) EXPR -> lbrace . EXPRSEMIPLUS rbrace
    (50) EXPRSEMIPLUS -> . EXPR semi
    (51) EXPRSEMIPLUS -> . EXPRSEMIPLUS EXPR semi
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 72
    EXPRSEMIPLUS                   shift and go to state 71

state 48

    (33) EXPR -> tilde . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 73

state 49

    (20) EXPR -> while . EXPR loop EXPR pool
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 74

state 50

    (12) EXPR -> identifier . larrow EXPR
    (17) EXPR -> identifier . lparen EXPRPLUS rparen
    (18) EXPR -> identifier . lparen rparen
    (39) EXPR -> identifier .

    larrow          shift and go to state 75
    lparen          shift and go to state 76
    rbrace          reduce using rule 39 (EXPR -> identifier .)
    at              reduce using rule 39 (EXPR -> identifier .)
    dot             reduce using rule 39 (EXPR -> identifier .)
    plus            reduce using rule 39 (EXPR -> identifier .)
    minus           reduce using rule 39 (EXPR -> identifier .)
    times           reduce using rule 39 (EXPR -> identifier .)
    divide          reduce using rule 39 (EXPR -> identifier .)
    lt              reduce using rule 39 (EXPR -> identifier .)
    le              reduce using rule 39 (EXPR -> identifier .)
    equals          reduce using rule 39 (EXPR -> identifier .)
    semi            reduce using rule 39 (EXPR -> identifier .)
    then            reduce using rule 39 (EXPR -> identifier .)
    rparen          reduce using rule 39 (EXPR -> identifier .)
    of              reduce using rule 39 (EXPR -> identifier .)
    loop            reduce using rule 39 (EXPR -> identifier .)
    comma           reduce using rule 39 (EXPR -> identifier .)
    else            reduce using rule 39 (EXPR -> identifier .)
    pool            reduce using rule 39 (EXPR -> identifier .)
    fi              reduce using rule 39 (EXPR -> identifier .)
    in              reduce using rule 39 (EXPR -> identifier .)


state 51

    (8) FEATURE -> identifier lparen rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 77


state 52

    (11) FORMAL -> identifier colon type .

    rparen          reduce using rule 11 (FORMAL -> identifier colon type .)
    comma           reduce using rule 11 (FORMAL -> identifier colon type .)


state 53

    (7) FEATURE -> identifier lparen FORMALPLUS rparen colon . type lbrace EXPR rbrace

    type            shift and go to state 78


state 54

    (47) FORMALPLUS -> FORMALPLUS comma FORMAL .

    rparen          reduce using rule 47 (FORMALPLUS -> FORMALPLUS comma FORMAL .)
    comma           reduce using rule 47 (FORMALPLUS -> FORMALPLUS comma FORMAL .)


state 55

    (19) EXPR -> if EXPR . then EXPR else EXPR fi
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    then            shift and go to state 79
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 56

    (35) EXPR -> EXPR le . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 80

state 57

    (32) EXPR -> EXPR divide . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 81

state 58

    (36) EXPR -> EXPR equals . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 82

state 59

    (31) EXPR -> EXPR times . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 83

state 60

    (34) EXPR -> EXPR lt . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 84

state 61

    (13) EXPR -> EXPR at . type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR at . type dot identifier lparen rparen

    type            shift and go to state 85


state 62

    (29) EXPR -> EXPR plus . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 86

state 63

    (30) EXPR -> EXPR minus . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 87

state 64

    (15) EXPR -> EXPR dot . identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR dot . identifier lparen rparen

    identifier      shift and go to state 88


state 65

    (28) EXPR -> isvoid EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 28 (EXPR -> isvoid EXPR .)
    plus            reduce using rule 28 (EXPR -> isvoid EXPR .)
    minus           reduce using rule 28 (EXPR -> isvoid EXPR .)
    times           reduce using rule 28 (EXPR -> isvoid EXPR .)
    divide          reduce using rule 28 (EXPR -> isvoid EXPR .)
    lt              reduce using rule 28 (EXPR -> isvoid EXPR .)
    le              reduce using rule 28 (EXPR -> isvoid EXPR .)
    equals          reduce using rule 28 (EXPR -> isvoid EXPR .)
    semi            reduce using rule 28 (EXPR -> isvoid EXPR .)
    then            reduce using rule 28 (EXPR -> isvoid EXPR .)
    rparen          reduce using rule 28 (EXPR -> isvoid EXPR .)
    of              reduce using rule 28 (EXPR -> isvoid EXPR .)
    loop            reduce using rule 28 (EXPR -> isvoid EXPR .)
    comma           reduce using rule 28 (EXPR -> isvoid EXPR .)
    else            reduce using rule 28 (EXPR -> isvoid EXPR .)
    pool            reduce using rule 28 (EXPR -> isvoid EXPR .)
    fi              reduce using rule 28 (EXPR -> isvoid EXPR .)
    in              reduce using rule 28 (EXPR -> isvoid EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64

  ! at              [ reduce using rule 28 (EXPR -> isvoid EXPR .) ]
  ! dot             [ reduce using rule 28 (EXPR -> isvoid EXPR .) ]
  ! plus            [ shift and go to state 62 ]
  ! minus           [ shift and go to state 63 ]
  ! times           [ shift and go to state 59 ]
  ! divide          [ shift and go to state 57 ]
  ! lt              [ shift and go to state 60 ]
  ! le              [ shift and go to state 56 ]
  ! equals          [ shift and go to state 58 ]


state 66

    (27) EXPR -> new type .

    rbrace          reduce using rule 27 (EXPR -> new type .)
    at              reduce using rule 27 (EXPR -> new type .)
    dot             reduce using rule 27 (EXPR -> new type .)
    plus            reduce using rule 27 (EXPR -> new type .)
    minus           reduce using rule 27 (EXPR -> new type .)
    times           reduce using rule 27 (EXPR -> new type .)
    divide          reduce using rule 27 (EXPR -> new type .)
    lt              reduce using rule 27 (EXPR -> new type .)
    le              reduce using rule 27 (EXPR -> new type .)
    equals          reduce using rule 27 (EXPR -> new type .)
    semi            reduce using rule 27 (EXPR -> new type .)
    then            reduce using rule 27 (EXPR -> new type .)
    rparen          reduce using rule 27 (EXPR -> new type .)
    of              reduce using rule 27 (EXPR -> new type .)
    loop            reduce using rule 27 (EXPR -> new type .)
    comma           reduce using rule 27 (EXPR -> new type .)
    else            reduce using rule 27 (EXPR -> new type .)
    pool            reduce using rule 27 (EXPR -> new type .)
    fi              reduce using rule 27 (EXPR -> new type .)
    in              reduce using rule 27 (EXPR -> new type .)


state 67

    (22) EXPR -> let identifier . colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> let identifier . colon type larrow EXPR in EXPR
    (24) EXPR -> let identifier . colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> let identifier . colon type in EXPR

    colon           shift and go to state 89


state 68

    (38) EXPR -> lparen EXPR . rparen
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rparen          shift and go to state 90
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 69

    (37) EXPR -> not EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 37 (EXPR -> not EXPR .)
    semi            reduce using rule 37 (EXPR -> not EXPR .)
    then            reduce using rule 37 (EXPR -> not EXPR .)
    rparen          reduce using rule 37 (EXPR -> not EXPR .)
    of              reduce using rule 37 (EXPR -> not EXPR .)
    loop            reduce using rule 37 (EXPR -> not EXPR .)
    comma           reduce using rule 37 (EXPR -> not EXPR .)
    else            reduce using rule 37 (EXPR -> not EXPR .)
    pool            reduce using rule 37 (EXPR -> not EXPR .)
    fi              reduce using rule 37 (EXPR -> not EXPR .)
    in              reduce using rule 37 (EXPR -> not EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58

  ! at              [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! dot             [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! plus            [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! minus           [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! times           [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! divide          [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! lt              [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! le              [ reduce using rule 37 (EXPR -> not EXPR .) ]
  ! equals          [ reduce using rule 37 (EXPR -> not EXPR .) ]


state 70

    (26) EXPR -> case EXPR . of IDTYPEARROWPLUS esac
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    of              shift and go to state 91
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 71

    (21) EXPR -> lbrace EXPRSEMIPLUS . rbrace
    (51) EXPRSEMIPLUS -> EXPRSEMIPLUS . EXPR semi
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    rbrace          shift and go to state 92
    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 93

state 72

    (50) EXPRSEMIPLUS -> EXPR . semi
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 94
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 73

    (33) EXPR -> tilde EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 33 (EXPR -> tilde EXPR .)
    plus            reduce using rule 33 (EXPR -> tilde EXPR .)
    minus           reduce using rule 33 (EXPR -> tilde EXPR .)
    times           reduce using rule 33 (EXPR -> tilde EXPR .)
    divide          reduce using rule 33 (EXPR -> tilde EXPR .)
    lt              reduce using rule 33 (EXPR -> tilde EXPR .)
    le              reduce using rule 33 (EXPR -> tilde EXPR .)
    equals          reduce using rule 33 (EXPR -> tilde EXPR .)
    semi            reduce using rule 33 (EXPR -> tilde EXPR .)
    then            reduce using rule 33 (EXPR -> tilde EXPR .)
    rparen          reduce using rule 33 (EXPR -> tilde EXPR .)
    of              reduce using rule 33 (EXPR -> tilde EXPR .)
    loop            reduce using rule 33 (EXPR -> tilde EXPR .)
    comma           reduce using rule 33 (EXPR -> tilde EXPR .)
    else            reduce using rule 33 (EXPR -> tilde EXPR .)
    pool            reduce using rule 33 (EXPR -> tilde EXPR .)
    fi              reduce using rule 33 (EXPR -> tilde EXPR .)
    in              reduce using rule 33 (EXPR -> tilde EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64

  ! at              [ reduce using rule 33 (EXPR -> tilde EXPR .) ]
  ! dot             [ reduce using rule 33 (EXPR -> tilde EXPR .) ]
  ! plus            [ shift and go to state 62 ]
  ! minus           [ shift and go to state 63 ]
  ! times           [ shift and go to state 59 ]
  ! divide          [ shift and go to state 57 ]
  ! lt              [ shift and go to state 60 ]
  ! le              [ shift and go to state 56 ]
  ! equals          [ shift and go to state 58 ]


state 74

    (20) EXPR -> while EXPR . loop EXPR pool
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    loop            shift and go to state 95
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 75

    (12) EXPR -> identifier larrow . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 96

state 76

    (17) EXPR -> identifier lparen . EXPRPLUS rparen
    (18) EXPR -> identifier lparen . rparen
    (48) EXPRPLUS -> . EXPR
    (49) EXPRPLUS -> . EXPRPLUS comma EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    rparen          shift and go to state 99
    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPRPLUS                       shift and go to state 97
    EXPR                           shift and go to state 98

state 77

    (8) FEATURE -> identifier lparen rparen colon type lbrace . EXPR rbrace
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 100

state 78

    (7) FEATURE -> identifier lparen FORMALPLUS rparen colon type . lbrace EXPR rbrace

    lbrace          shift and go to state 101


state 79

    (19) EXPR -> if EXPR then . EXPR else EXPR fi
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 102

state 80

    (35) EXPR -> EXPR le EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 35 (EXPR -> EXPR le EXPR .)
    lt              reduce using rule 35 (EXPR -> EXPR le EXPR .)
    le              reduce using rule 35 (EXPR -> EXPR le EXPR .)
    equals          reduce using rule 35 (EXPR -> EXPR le EXPR .)
    semi            reduce using rule 35 (EXPR -> EXPR le EXPR .)
    then            reduce using rule 35 (EXPR -> EXPR le EXPR .)
    rparen          reduce using rule 35 (EXPR -> EXPR le EXPR .)
    of              reduce using rule 35 (EXPR -> EXPR le EXPR .)
    loop            reduce using rule 35 (EXPR -> EXPR le EXPR .)
    comma           reduce using rule 35 (EXPR -> EXPR le EXPR .)
    else            reduce using rule 35 (EXPR -> EXPR le EXPR .)
    pool            reduce using rule 35 (EXPR -> EXPR le EXPR .)
    fi              reduce using rule 35 (EXPR -> EXPR le EXPR .)
    in              reduce using rule 35 (EXPR -> EXPR le EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57

  ! at              [ reduce using rule 35 (EXPR -> EXPR le EXPR .) ]
  ! dot             [ reduce using rule 35 (EXPR -> EXPR le EXPR .) ]
  ! plus            [ reduce using rule 35 (EXPR -> EXPR le EXPR .) ]
  ! minus           [ reduce using rule 35 (EXPR -> EXPR le EXPR .) ]
  ! times           [ reduce using rule 35 (EXPR -> EXPR le EXPR .) ]
  ! divide          [ reduce using rule 35 (EXPR -> EXPR le EXPR .) ]
  ! lt              [ shift and go to state 60 ]
  ! le              [ shift and go to state 56 ]
  ! equals          [ shift and go to state 58 ]


state 81

    (32) EXPR -> EXPR divide EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    plus            reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    minus           reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    times           reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    divide          reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    lt              reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    le              reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    equals          reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    semi            reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    then            reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    rparen          reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    of              reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    loop            reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    comma           reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    else            reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    pool            reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    fi              reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    in              reduce using rule 32 (EXPR -> EXPR divide EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64

  ! at              [ reduce using rule 32 (EXPR -> EXPR divide EXPR .) ]
  ! dot             [ reduce using rule 32 (EXPR -> EXPR divide EXPR .) ]
  ! plus            [ shift and go to state 62 ]
  ! minus           [ shift and go to state 63 ]
  ! times           [ shift and go to state 59 ]
  ! divide          [ shift and go to state 57 ]
  ! lt              [ shift and go to state 60 ]
  ! le              [ shift and go to state 56 ]
  ! equals          [ shift and go to state 58 ]


state 82

    (36) EXPR -> EXPR equals EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    lt              reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    le              reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    equals          reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    semi            reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    then            reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    rparen          reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    of              reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    loop            reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    comma           reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    else            reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    pool            reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    fi              reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    in              reduce using rule 36 (EXPR -> EXPR equals EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57

  ! at              [ reduce using rule 36 (EXPR -> EXPR equals EXPR .) ]
  ! dot             [ reduce using rule 36 (EXPR -> EXPR equals EXPR .) ]
  ! plus            [ reduce using rule 36 (EXPR -> EXPR equals EXPR .) ]
  ! minus           [ reduce using rule 36 (EXPR -> EXPR equals EXPR .) ]
  ! times           [ reduce using rule 36 (EXPR -> EXPR equals EXPR .) ]
  ! divide          [ reduce using rule 36 (EXPR -> EXPR equals EXPR .) ]
  ! lt              [ shift and go to state 60 ]
  ! le              [ shift and go to state 56 ]
  ! equals          [ shift and go to state 58 ]


state 83

    (31) EXPR -> EXPR times EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 31 (EXPR -> EXPR times EXPR .)
    plus            reduce using rule 31 (EXPR -> EXPR times EXPR .)
    minus           reduce using rule 31 (EXPR -> EXPR times EXPR .)
    times           reduce using rule 31 (EXPR -> EXPR times EXPR .)
    divide          reduce using rule 31 (EXPR -> EXPR times EXPR .)
    lt              reduce using rule 31 (EXPR -> EXPR times EXPR .)
    le              reduce using rule 31 (EXPR -> EXPR times EXPR .)
    equals          reduce using rule 31 (EXPR -> EXPR times EXPR .)
    semi            reduce using rule 31 (EXPR -> EXPR times EXPR .)
    then            reduce using rule 31 (EXPR -> EXPR times EXPR .)
    rparen          reduce using rule 31 (EXPR -> EXPR times EXPR .)
    of              reduce using rule 31 (EXPR -> EXPR times EXPR .)
    loop            reduce using rule 31 (EXPR -> EXPR times EXPR .)
    comma           reduce using rule 31 (EXPR -> EXPR times EXPR .)
    else            reduce using rule 31 (EXPR -> EXPR times EXPR .)
    pool            reduce using rule 31 (EXPR -> EXPR times EXPR .)
    fi              reduce using rule 31 (EXPR -> EXPR times EXPR .)
    in              reduce using rule 31 (EXPR -> EXPR times EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64

  ! at              [ reduce using rule 31 (EXPR -> EXPR times EXPR .) ]
  ! dot             [ reduce using rule 31 (EXPR -> EXPR times EXPR .) ]
  ! plus            [ shift and go to state 62 ]
  ! minus           [ shift and go to state 63 ]
  ! times           [ shift and go to state 59 ]
  ! divide          [ shift and go to state 57 ]
  ! lt              [ shift and go to state 60 ]
  ! le              [ shift and go to state 56 ]
  ! equals          [ shift and go to state 58 ]


state 84

    (34) EXPR -> EXPR lt EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    lt              reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    le              reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    equals          reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    semi            reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    then            reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    rparen          reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    of              reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    loop            reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    comma           reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    else            reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    pool            reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    fi              reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    in              reduce using rule 34 (EXPR -> EXPR lt EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57

  ! at              [ reduce using rule 34 (EXPR -> EXPR lt EXPR .) ]
  ! dot             [ reduce using rule 34 (EXPR -> EXPR lt EXPR .) ]
  ! plus            [ reduce using rule 34 (EXPR -> EXPR lt EXPR .) ]
  ! minus           [ reduce using rule 34 (EXPR -> EXPR lt EXPR .) ]
  ! times           [ reduce using rule 34 (EXPR -> EXPR lt EXPR .) ]
  ! divide          [ reduce using rule 34 (EXPR -> EXPR lt EXPR .) ]
  ! lt              [ shift and go to state 60 ]
  ! le              [ shift and go to state 56 ]
  ! equals          [ shift and go to state 58 ]


state 85

    (13) EXPR -> EXPR at type . dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR at type . dot identifier lparen rparen

    dot             shift and go to state 103


state 86

    (29) EXPR -> EXPR plus EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    plus            reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    minus           reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    lt              reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    le              reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    equals          reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    semi            reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    then            reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    rparen          reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    of              reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    loop            reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    comma           reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    else            reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    pool            reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    fi              reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    in              reduce using rule 29 (EXPR -> EXPR plus EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    times           shift and go to state 59
    divide          shift and go to state 57

  ! at              [ reduce using rule 29 (EXPR -> EXPR plus EXPR .) ]
  ! dot             [ reduce using rule 29 (EXPR -> EXPR plus EXPR .) ]
  ! times           [ reduce using rule 29 (EXPR -> EXPR plus EXPR .) ]
  ! divide          [ reduce using rule 29 (EXPR -> EXPR plus EXPR .) ]
  ! plus            [ shift and go to state 62 ]
  ! minus           [ shift and go to state 63 ]
  ! lt              [ shift and go to state 60 ]
  ! le              [ shift and go to state 56 ]
  ! equals          [ shift and go to state 58 ]


state 87

    (30) EXPR -> EXPR minus EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    plus            reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    minus           reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    lt              reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    le              reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    equals          reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    semi            reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    then            reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    rparen          reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    of              reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    loop            reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    comma           reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    else            reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    pool            reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    fi              reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    in              reduce using rule 30 (EXPR -> EXPR minus EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    times           shift and go to state 59
    divide          shift and go to state 57

  ! at              [ reduce using rule 30 (EXPR -> EXPR minus EXPR .) ]
  ! dot             [ reduce using rule 30 (EXPR -> EXPR minus EXPR .) ]
  ! times           [ reduce using rule 30 (EXPR -> EXPR minus EXPR .) ]
  ! divide          [ reduce using rule 30 (EXPR -> EXPR minus EXPR .) ]
  ! plus            [ shift and go to state 62 ]
  ! minus           [ shift and go to state 63 ]
  ! lt              [ shift and go to state 60 ]
  ! le              [ shift and go to state 56 ]
  ! equals          [ shift and go to state 58 ]


state 88

    (15) EXPR -> EXPR dot identifier . lparen EXPRPLUS rparen
    (16) EXPR -> EXPR dot identifier . lparen rparen

    lparen          shift and go to state 104


state 89

    (22) EXPR -> let identifier colon . type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> let identifier colon . type larrow EXPR in EXPR
    (24) EXPR -> let identifier colon . type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> let identifier colon . type in EXPR

    type            shift and go to state 105


state 90

    (38) EXPR -> lparen EXPR rparen .

    rbrace          reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    at              reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    dot             reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    plus            reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    minus           reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    times           reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    divide          reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    lt              reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    le              reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    equals          reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    semi            reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    then            reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    rparen          reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    of              reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    loop            reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    comma           reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    else            reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    pool            reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    fi              reduce using rule 38 (EXPR -> lparen EXPR rparen .)
    in              reduce using rule 38 (EXPR -> lparen EXPR rparen .)


state 91

    (26) EXPR -> case EXPR of . IDTYPEARROWPLUS esac
    (56) IDTYPEARROWPLUS -> . identifier colon type rarrow EXPR semi
    (57) IDTYPEARROWPLUS -> . IDTYPEARROWPLUS identifier colon type rarrow EXPR semi

    identifier      shift and go to state 107

    IDTYPEARROWPLUS                shift and go to state 106

state 92

    (21) EXPR -> lbrace EXPRSEMIPLUS rbrace .

    rbrace          reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    at              reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    dot             reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    plus            reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    minus           reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    times           reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    divide          reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    lt              reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    le              reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    equals          reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    semi            reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    then            reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    rparen          reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    of              reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    loop            reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    comma           reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    else            reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    pool            reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    fi              reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)
    in              reduce using rule 21 (EXPR -> lbrace EXPRSEMIPLUS rbrace .)


state 93

    (51) EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR . semi
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 108
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 94

    (50) EXPRSEMIPLUS -> EXPR semi .

    rbrace          reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    identifier      reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    if              reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    while           reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    lbrace          reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    let             reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    case            reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    new             reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    isvoid          reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    tilde           reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    not             reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    lparen          reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    integer         reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    string          reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    true            reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)
    false           reduce using rule 50 (EXPRSEMIPLUS -> EXPR semi .)


state 95

    (20) EXPR -> while EXPR loop . EXPR pool
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 109

state 96

    (12) EXPR -> identifier larrow EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    semi            reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    then            reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    rparen          reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    of              reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    loop            reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    comma           reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    else            reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    pool            reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    fi              reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    in              reduce using rule 12 (EXPR -> identifier larrow EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58

  ! at              [ reduce using rule 12 (EXPR -> identifier larrow EXPR .) ]
  ! dot             [ reduce using rule 12 (EXPR -> identifier larrow EXPR .) ]
  ! plus            [ reduce using rule 12 (EXPR -> identifier larrow EXPR .) ]
  ! minus           [ reduce using rule 12 (EXPR -> identifier larrow EXPR .) ]
  ! times           [ reduce using rule 12 (EXPR -> identifier larrow EXPR .) ]
  ! divide          [ reduce using rule 12 (EXPR -> identifier larrow EXPR .) ]
  ! lt              [ reduce using rule 12 (EXPR -> identifier larrow EXPR .) ]
  ! le              [ reduce using rule 12 (EXPR -> identifier larrow EXPR .) ]
  ! equals          [ reduce using rule 12 (EXPR -> identifier larrow EXPR .) ]


state 97

    (17) EXPR -> identifier lparen EXPRPLUS . rparen
    (49) EXPRPLUS -> EXPRPLUS . comma EXPR

    rparen          shift and go to state 110
    comma           shift and go to state 111


state 98

    (48) EXPRPLUS -> EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rparen          reduce using rule 48 (EXPRPLUS -> EXPR .)
    comma           reduce using rule 48 (EXPRPLUS -> EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 99

    (18) EXPR -> identifier lparen rparen .

    rbrace          reduce using rule 18 (EXPR -> identifier lparen rparen .)
    at              reduce using rule 18 (EXPR -> identifier lparen rparen .)
    dot             reduce using rule 18 (EXPR -> identifier lparen rparen .)
    plus            reduce using rule 18 (EXPR -> identifier lparen rparen .)
    minus           reduce using rule 18 (EXPR -> identifier lparen rparen .)
    times           reduce using rule 18 (EXPR -> identifier lparen rparen .)
    divide          reduce using rule 18 (EXPR -> identifier lparen rparen .)
    lt              reduce using rule 18 (EXPR -> identifier lparen rparen .)
    le              reduce using rule 18 (EXPR -> identifier lparen rparen .)
    equals          reduce using rule 18 (EXPR -> identifier lparen rparen .)
    semi            reduce using rule 18 (EXPR -> identifier lparen rparen .)
    then            reduce using rule 18 (EXPR -> identifier lparen rparen .)
    rparen          reduce using rule 18 (EXPR -> identifier lparen rparen .)
    of              reduce using rule 18 (EXPR -> identifier lparen rparen .)
    loop            reduce using rule 18 (EXPR -> identifier lparen rparen .)
    comma           reduce using rule 18 (EXPR -> identifier lparen rparen .)
    else            reduce using rule 18 (EXPR -> identifier lparen rparen .)
    pool            reduce using rule 18 (EXPR -> identifier lparen rparen .)
    fi              reduce using rule 18 (EXPR -> identifier lparen rparen .)
    in              reduce using rule 18 (EXPR -> identifier lparen rparen .)


state 100

    (8) FEATURE -> identifier lparen rparen colon type lbrace EXPR . rbrace
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          shift and go to state 112
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 101

    (7) FEATURE -> identifier lparen FORMALPLUS rparen colon type lbrace . EXPR rbrace
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 113

state 102

    (19) EXPR -> if EXPR then EXPR . else EXPR fi
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    else            shift and go to state 114
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 103

    (13) EXPR -> EXPR at type dot . identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR at type dot . identifier lparen rparen

    identifier      shift and go to state 115


state 104

    (15) EXPR -> EXPR dot identifier lparen . EXPRPLUS rparen
    (16) EXPR -> EXPR dot identifier lparen . rparen
    (48) EXPRPLUS -> . EXPR
    (49) EXPRPLUS -> . EXPRPLUS comma EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    rparen          shift and go to state 117
    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 98
    EXPRPLUS                       shift and go to state 116

state 105

    (22) EXPR -> let identifier colon type . larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> let identifier colon type . larrow EXPR in EXPR
    (24) EXPR -> let identifier colon type . IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> let identifier colon type . in EXPR
    (52) IDTYPEEXPRPLUS -> . comma identifier colon type larrow EXPR
    (53) IDTYPEEXPRPLUS -> . comma identifier colon type
    (54) IDTYPEEXPRPLUS -> . IDTYPEEXPRPLUS comma identifier colon type larrow EXPR
    (55) IDTYPEEXPRPLUS -> . IDTYPEEXPRPLUS comma identifier colon type

    larrow          shift and go to state 120
    in              shift and go to state 121
    comma           shift and go to state 119

    IDTYPEEXPRPLUS                 shift and go to state 118

state 106

    (26) EXPR -> case EXPR of IDTYPEARROWPLUS . esac
    (57) IDTYPEARROWPLUS -> IDTYPEARROWPLUS . identifier colon type rarrow EXPR semi

    esac            shift and go to state 122
    identifier      shift and go to state 123


state 107

    (56) IDTYPEARROWPLUS -> identifier . colon type rarrow EXPR semi

    colon           shift and go to state 124


state 108

    (51) EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .

    rbrace          reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    identifier      reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    if              reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    while           reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    lbrace          reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    let             reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    case            reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    new             reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    isvoid          reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    tilde           reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    not             reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    lparen          reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    integer         reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    string          reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    true            reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)
    false           reduce using rule 51 (EXPRSEMIPLUS -> EXPRSEMIPLUS EXPR semi .)


state 109

    (20) EXPR -> while EXPR loop EXPR . pool
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    pool            shift and go to state 125
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 110

    (17) EXPR -> identifier lparen EXPRPLUS rparen .

    rbrace          reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    at              reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    dot             reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    plus            reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    minus           reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    times           reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    divide          reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    lt              reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    le              reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    equals          reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    semi            reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    then            reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    rparen          reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    of              reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    loop            reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    comma           reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    else            reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    pool            reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    fi              reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)
    in              reduce using rule 17 (EXPR -> identifier lparen EXPRPLUS rparen .)


state 111

    (49) EXPRPLUS -> EXPRPLUS comma . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 126

state 112

    (8) FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 8 (FEATURE -> identifier lparen rparen colon type lbrace EXPR rbrace .)


state 113

    (7) FEATURE -> identifier lparen FORMALPLUS rparen colon type lbrace EXPR . rbrace
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rbrace          shift and go to state 127
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 114

    (19) EXPR -> if EXPR then EXPR else . EXPR fi
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 128

state 115

    (13) EXPR -> EXPR at type dot identifier . lparen EXPRPLUS rparen
    (14) EXPR -> EXPR at type dot identifier . lparen rparen

    lparen          shift and go to state 129


state 116

    (15) EXPR -> EXPR dot identifier lparen EXPRPLUS . rparen
    (49) EXPRPLUS -> EXPRPLUS . comma EXPR

    rparen          shift and go to state 130
    comma           shift and go to state 111


state 117

    (16) EXPR -> EXPR dot identifier lparen rparen .

    rbrace          reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    at              reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    dot             reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    plus            reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    minus           reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    times           reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    divide          reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    lt              reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    le              reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    equals          reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    semi            reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    then            reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    rparen          reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    of              reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    loop            reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    comma           reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    else            reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    pool            reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    fi              reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)
    in              reduce using rule 16 (EXPR -> EXPR dot identifier lparen rparen .)


state 118

    (24) EXPR -> let identifier colon type IDTYPEEXPRPLUS . in EXPR
    (54) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS . comma identifier colon type larrow EXPR
    (55) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS . comma identifier colon type

    in              shift and go to state 132
    comma           shift and go to state 131


state 119

    (52) IDTYPEEXPRPLUS -> comma . identifier colon type larrow EXPR
    (53) IDTYPEEXPRPLUS -> comma . identifier colon type

    identifier      shift and go to state 133


state 120

    (22) EXPR -> let identifier colon type larrow . EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> let identifier colon type larrow . EXPR in EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 134

state 121

    (25) EXPR -> let identifier colon type in . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 135

state 122

    (26) EXPR -> case EXPR of IDTYPEARROWPLUS esac .

    rbrace          reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    at              reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    dot             reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    plus            reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    minus           reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    times           reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    divide          reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    lt              reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    le              reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    equals          reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    semi            reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    then            reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    rparen          reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    of              reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    loop            reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    comma           reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    else            reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    pool            reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    fi              reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)
    in              reduce using rule 26 (EXPR -> case EXPR of IDTYPEARROWPLUS esac .)


state 123

    (57) IDTYPEARROWPLUS -> IDTYPEARROWPLUS identifier . colon type rarrow EXPR semi

    colon           shift and go to state 136


state 124

    (56) IDTYPEARROWPLUS -> identifier colon . type rarrow EXPR semi

    type            shift and go to state 137


state 125

    (20) EXPR -> while EXPR loop EXPR pool .

    rbrace          reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    at              reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    dot             reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    plus            reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    minus           reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    times           reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    divide          reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    lt              reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    le              reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    equals          reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    semi            reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    then            reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    rparen          reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    of              reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    loop            reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    comma           reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    else            reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    pool            reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    fi              reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)
    in              reduce using rule 20 (EXPR -> while EXPR loop EXPR pool .)


state 126

    (49) EXPRPLUS -> EXPRPLUS comma EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    rparen          reduce using rule 49 (EXPRPLUS -> EXPRPLUS comma EXPR .)
    comma           reduce using rule 49 (EXPRPLUS -> EXPRPLUS comma EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 127

    (7) FEATURE -> identifier lparen FORMALPLUS rparen colon type lbrace EXPR rbrace .

    semi            reduce using rule 7 (FEATURE -> identifier lparen FORMALPLUS rparen colon type lbrace EXPR rbrace .)


state 128

    (19) EXPR -> if EXPR then EXPR else EXPR . fi
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    fi              shift and go to state 138
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 129

    (13) EXPR -> EXPR at type dot identifier lparen . EXPRPLUS rparen
    (14) EXPR -> EXPR at type dot identifier lparen . rparen
    (48) EXPRPLUS -> . EXPR
    (49) EXPRPLUS -> . EXPRPLUS comma EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    rparen          shift and go to state 140
    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 98
    EXPRPLUS                       shift and go to state 139

state 130

    (15) EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .

    rbrace          reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    at              reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    dot             reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    plus            reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    minus           reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    times           reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    divide          reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    lt              reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    le              reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    equals          reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    semi            reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    then            reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    rparen          reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    of              reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    loop            reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    comma           reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    else            reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    pool            reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    fi              reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)
    in              reduce using rule 15 (EXPR -> EXPR dot identifier lparen EXPRPLUS rparen .)


state 131

    (54) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma . identifier colon type larrow EXPR
    (55) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma . identifier colon type

    identifier      shift and go to state 141


state 132

    (24) EXPR -> let identifier colon type IDTYPEEXPRPLUS in . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 142

state 133

    (52) IDTYPEEXPRPLUS -> comma identifier . colon type larrow EXPR
    (53) IDTYPEEXPRPLUS -> comma identifier . colon type

    colon           shift and go to state 143


state 134

    (22) EXPR -> let identifier colon type larrow EXPR . IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> let identifier colon type larrow EXPR . in EXPR
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR
    (52) IDTYPEEXPRPLUS -> . comma identifier colon type larrow EXPR
    (53) IDTYPEEXPRPLUS -> . comma identifier colon type
    (54) IDTYPEEXPRPLUS -> . IDTYPEEXPRPLUS comma identifier colon type larrow EXPR
    (55) IDTYPEEXPRPLUS -> . IDTYPEEXPRPLUS comma identifier colon type

    in              shift and go to state 145
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58
    comma           shift and go to state 119

    IDTYPEEXPRPLUS                 shift and go to state 144

state 135

    (25) EXPR -> let identifier colon type in EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    semi            reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    then            reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    rparen          reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    of              reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    loop            reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    comma           reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    else            reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    pool            reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    fi              reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    in              reduce using rule 25 (EXPR -> let identifier colon type in EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58

  ! at              [ reduce using rule 25 (EXPR -> let identifier colon type in EXPR .) ]
  ! dot             [ reduce using rule 25 (EXPR -> let identifier colon type in EXPR .) ]
  ! plus            [ reduce using rule 25 (EXPR -> let identifier colon type in EXPR .) ]
  ! minus           [ reduce using rule 25 (EXPR -> let identifier colon type in EXPR .) ]
  ! times           [ reduce using rule 25 (EXPR -> let identifier colon type in EXPR .) ]
  ! divide          [ reduce using rule 25 (EXPR -> let identifier colon type in EXPR .) ]
  ! lt              [ reduce using rule 25 (EXPR -> let identifier colon type in EXPR .) ]
  ! le              [ reduce using rule 25 (EXPR -> let identifier colon type in EXPR .) ]
  ! equals          [ reduce using rule 25 (EXPR -> let identifier colon type in EXPR .) ]


state 136

    (57) IDTYPEARROWPLUS -> IDTYPEARROWPLUS identifier colon . type rarrow EXPR semi

    type            shift and go to state 146


state 137

    (56) IDTYPEARROWPLUS -> identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 147


state 138

    (19) EXPR -> if EXPR then EXPR else EXPR fi .

    rbrace          reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    at              reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    dot             reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    plus            reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    minus           reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    times           reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    divide          reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    lt              reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    le              reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    equals          reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    semi            reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    then            reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    rparen          reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    of              reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    loop            reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    comma           reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    else            reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    pool            reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    fi              reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)
    in              reduce using rule 19 (EXPR -> if EXPR then EXPR else EXPR fi .)


state 139

    (13) EXPR -> EXPR at type dot identifier lparen EXPRPLUS . rparen
    (49) EXPRPLUS -> EXPRPLUS . comma EXPR

    rparen          shift and go to state 148
    comma           shift and go to state 111


state 140

    (14) EXPR -> EXPR at type dot identifier lparen rparen .

    rbrace          reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    at              reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    dot             reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    plus            reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    minus           reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    times           reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    divide          reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    lt              reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    le              reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    equals          reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    semi            reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    then            reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    rparen          reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    of              reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    loop            reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    comma           reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    else            reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    pool            reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    fi              reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)
    in              reduce using rule 14 (EXPR -> EXPR at type dot identifier lparen rparen .)


state 141

    (54) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier . colon type larrow EXPR
    (55) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier . colon type

    colon           shift and go to state 149


state 142

    (24) EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    semi            reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    then            reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    rparen          reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    of              reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    loop            reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    comma           reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    else            reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    pool            reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    fi              reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    in              reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58

  ! at              [ reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .) ]
  ! dot             [ reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .) ]
  ! plus            [ reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .) ]
  ! minus           [ reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .) ]
  ! times           [ reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .) ]
  ! divide          [ reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .) ]
  ! lt              [ reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .) ]
  ! le              [ reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .) ]
  ! equals          [ reduce using rule 24 (EXPR -> let identifier colon type IDTYPEEXPRPLUS in EXPR .) ]


state 143

    (52) IDTYPEEXPRPLUS -> comma identifier colon . type larrow EXPR
    (53) IDTYPEEXPRPLUS -> comma identifier colon . type

    type            shift and go to state 150


state 144

    (22) EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS . in EXPR
    (54) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS . comma identifier colon type larrow EXPR
    (55) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS . comma identifier colon type

    in              shift and go to state 151
    comma           shift and go to state 131


state 145

    (23) EXPR -> let identifier colon type larrow EXPR in . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 152

state 146

    (57) IDTYPEARROWPLUS -> IDTYPEARROWPLUS identifier colon type . rarrow EXPR semi

    rarrow          shift and go to state 153


state 147

    (56) IDTYPEARROWPLUS -> identifier colon type rarrow . EXPR semi
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 154

state 148

    (13) EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .

    rbrace          reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    at              reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    dot             reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    plus            reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    minus           reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    times           reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    divide          reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    lt              reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    le              reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    equals          reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    semi            reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    then            reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    rparen          reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    of              reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    loop            reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    comma           reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    else            reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    pool            reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    fi              reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)
    in              reduce using rule 13 (EXPR -> EXPR at type dot identifier lparen EXPRPLUS rparen .)


state 149

    (54) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon . type larrow EXPR
    (55) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon . type

    type            shift and go to state 155


state 150

    (52) IDTYPEEXPRPLUS -> comma identifier colon type . larrow EXPR
    (53) IDTYPEEXPRPLUS -> comma identifier colon type .

    larrow          shift and go to state 156
    in              reduce using rule 53 (IDTYPEEXPRPLUS -> comma identifier colon type .)
    comma           reduce using rule 53 (IDTYPEEXPRPLUS -> comma identifier colon type .)


state 151

    (22) EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 157

state 152

    (23) EXPR -> let identifier colon type larrow EXPR in EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    semi            reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    then            reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    rparen          reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    of              reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    loop            reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    comma           reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    else            reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    pool            reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    fi              reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    in              reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58

  ! at              [ reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! dot             [ reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! plus            [ reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! minus           [ reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! times           [ reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! divide          [ reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! lt              [ reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! le              [ reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]
  ! equals          [ reduce using rule 23 (EXPR -> let identifier colon type larrow EXPR in EXPR .) ]


state 153

    (57) IDTYPEARROWPLUS -> IDTYPEARROWPLUS identifier colon type rarrow . EXPR semi
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 158

state 154

    (56) IDTYPEARROWPLUS -> identifier colon type rarrow EXPR . semi
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 159
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 155

    (54) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon type . larrow EXPR
    (55) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon type .

    larrow          shift and go to state 160
    in              reduce using rule 55 (IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon type .)
    comma           reduce using rule 55 (IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon type .)


state 156

    (52) IDTYPEEXPRPLUS -> comma identifier colon type larrow . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 161

state 157

    (22) EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

  ! shift/reduce conflict for at resolved as shift
  ! shift/reduce conflict for dot resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for le resolved as shift
  ! shift/reduce conflict for equals resolved as shift
    rbrace          reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    semi            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    then            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    rparen          reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    of              reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    loop            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    comma           reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    else            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    pool            reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    fi              reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    in              reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58

  ! at              [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .) ]
  ! dot             [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .) ]
  ! plus            [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .) ]
  ! minus           [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .) ]
  ! times           [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .) ]
  ! divide          [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .) ]
  ! lt              [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .) ]
  ! le              [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .) ]
  ! equals          [ reduce using rule 22 (EXPR -> let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR .) ]


state 158

    (57) IDTYPEARROWPLUS -> IDTYPEARROWPLUS identifier colon type rarrow EXPR . semi
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    semi            shift and go to state 162
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 159

    (56) IDTYPEARROWPLUS -> identifier colon type rarrow EXPR semi .

    esac            reduce using rule 56 (IDTYPEARROWPLUS -> identifier colon type rarrow EXPR semi .)
    identifier      reduce using rule 56 (IDTYPEARROWPLUS -> identifier colon type rarrow EXPR semi .)


state 160

    (54) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon type larrow . EXPR
    (12) EXPR -> . identifier larrow EXPR
    (13) EXPR -> . EXPR at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> . EXPR at type dot identifier lparen rparen
    (15) EXPR -> . EXPR dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> . EXPR dot identifier lparen rparen
    (17) EXPR -> . identifier lparen EXPRPLUS rparen
    (18) EXPR -> . identifier lparen rparen
    (19) EXPR -> . if EXPR then EXPR else EXPR fi
    (20) EXPR -> . while EXPR loop EXPR pool
    (21) EXPR -> . lbrace EXPRSEMIPLUS rbrace
    (22) EXPR -> . let identifier colon type larrow EXPR IDTYPEEXPRPLUS in EXPR
    (23) EXPR -> . let identifier colon type larrow EXPR in EXPR
    (24) EXPR -> . let identifier colon type IDTYPEEXPRPLUS in EXPR
    (25) EXPR -> . let identifier colon type in EXPR
    (26) EXPR -> . case EXPR of IDTYPEARROWPLUS esac
    (27) EXPR -> . new type
    (28) EXPR -> . isvoid EXPR
    (29) EXPR -> . EXPR plus EXPR
    (30) EXPR -> . EXPR minus EXPR
    (31) EXPR -> . EXPR times EXPR
    (32) EXPR -> . EXPR divide EXPR
    (33) EXPR -> . tilde EXPR
    (34) EXPR -> . EXPR lt EXPR
    (35) EXPR -> . EXPR le EXPR
    (36) EXPR -> . EXPR equals EXPR
    (37) EXPR -> . not EXPR
    (38) EXPR -> . lparen EXPR rparen
    (39) EXPR -> . identifier
    (40) EXPR -> . integer
    (41) EXPR -> . string
    (42) EXPR -> . true
    (43) EXPR -> . false

    identifier      shift and go to state 50
    if              shift and go to state 36
    while           shift and go to state 49
    lbrace          shift and go to state 47
    let             shift and go to state 42
    case            shift and go to state 46
    new             shift and go to state 40
    isvoid          shift and go to state 39
    tilde           shift and go to state 48
    not             shift and go to state 44
    lparen          shift and go to state 43
    integer         shift and go to state 37
    string          shift and go to state 41
    true            shift and go to state 45
    false           shift and go to state 35

    EXPR                           shift and go to state 163

state 161

    (52) IDTYPEEXPRPLUS -> comma identifier colon type larrow EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    in              reduce using rule 52 (IDTYPEEXPRPLUS -> comma identifier colon type larrow EXPR .)
    comma           reduce using rule 52 (IDTYPEEXPRPLUS -> comma identifier colon type larrow EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58


state 162

    (57) IDTYPEARROWPLUS -> IDTYPEARROWPLUS identifier colon type rarrow EXPR semi .

    esac            reduce using rule 57 (IDTYPEARROWPLUS -> IDTYPEARROWPLUS identifier colon type rarrow EXPR semi .)
    identifier      reduce using rule 57 (IDTYPEARROWPLUS -> IDTYPEARROWPLUS identifier colon type rarrow EXPR semi .)


state 163

    (54) IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon type larrow EXPR .
    (13) EXPR -> EXPR . at type dot identifier lparen EXPRPLUS rparen
    (14) EXPR -> EXPR . at type dot identifier lparen rparen
    (15) EXPR -> EXPR . dot identifier lparen EXPRPLUS rparen
    (16) EXPR -> EXPR . dot identifier lparen rparen
    (29) EXPR -> EXPR . plus EXPR
    (30) EXPR -> EXPR . minus EXPR
    (31) EXPR -> EXPR . times EXPR
    (32) EXPR -> EXPR . divide EXPR
    (34) EXPR -> EXPR . lt EXPR
    (35) EXPR -> EXPR . le EXPR
    (36) EXPR -> EXPR . equals EXPR

    in              reduce using rule 54 (IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon type larrow EXPR .)
    comma           reduce using rule 54 (IDTYPEEXPRPLUS -> IDTYPEEXPRPLUS comma identifier colon type larrow EXPR .)
    at              shift and go to state 61
    dot             shift and go to state 64
    plus            shift and go to state 62
    minus           shift and go to state 63
    times           shift and go to state 59
    divide          shift and go to state 57
    lt              shift and go to state 60
    le              shift and go to state 56
    equals          shift and go to state 58

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for at in state 135 resolved as shift
WARNING: shift/reduce conflict for dot in state 135 resolved as shift
WARNING: shift/reduce conflict for plus in state 135 resolved as shift
WARNING: shift/reduce conflict for minus in state 135 resolved as shift
WARNING: shift/reduce conflict for times in state 135 resolved as shift
WARNING: shift/reduce conflict for divide in state 135 resolved as shift
WARNING: shift/reduce conflict for lt in state 135 resolved as shift
WARNING: shift/reduce conflict for le in state 135 resolved as shift
WARNING: shift/reduce conflict for equals in state 135 resolved as shift
WARNING: shift/reduce conflict for at in state 142 resolved as shift
WARNING: shift/reduce conflict for dot in state 142 resolved as shift
WARNING: shift/reduce conflict for plus in state 142 resolved as shift
WARNING: shift/reduce conflict for minus in state 142 resolved as shift
WARNING: shift/reduce conflict for times in state 142 resolved as shift
WARNING: shift/reduce conflict for divide in state 142 resolved as shift
WARNING: shift/reduce conflict for lt in state 142 resolved as shift
WARNING: shift/reduce conflict for le in state 142 resolved as shift
WARNING: shift/reduce conflict for equals in state 142 resolved as shift
WARNING: shift/reduce conflict for at in state 152 resolved as shift
WARNING: shift/reduce conflict for dot in state 152 resolved as shift
WARNING: shift/reduce conflict for plus in state 152 resolved as shift
WARNING: shift/reduce conflict for minus in state 152 resolved as shift
WARNING: shift/reduce conflict for times in state 152 resolved as shift
WARNING: shift/reduce conflict for divide in state 152 resolved as shift
WARNING: shift/reduce conflict for lt in state 152 resolved as shift
WARNING: shift/reduce conflict for le in state 152 resolved as shift
WARNING: shift/reduce conflict for equals in state 152 resolved as shift
WARNING: shift/reduce conflict for at in state 157 resolved as shift
WARNING: shift/reduce conflict for dot in state 157 resolved as shift
WARNING: shift/reduce conflict for plus in state 157 resolved as shift
WARNING: shift/reduce conflict for minus in state 157 resolved as shift
WARNING: shift/reduce conflict for times in state 157 resolved as shift
WARNING: shift/reduce conflict for divide in state 157 resolved as shift
WARNING: shift/reduce conflict for lt in state 157 resolved as shift
WARNING: shift/reduce conflict for le in state 157 resolved as shift
WARNING: shift/reduce conflict for equals in state 157 resolved as shift
