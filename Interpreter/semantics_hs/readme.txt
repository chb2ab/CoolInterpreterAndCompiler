Crispin Bernier
chb2ab
pa4

	I implemented my semantic analyzer in Haskell because I wanted to get more experience using a functional programming language. The first step in my implementation was deserializing the abstract syntax tree from PA3. The serialized AST is read into a list of strings and passed into the readAST function which is located in Deserializer.hs. This function converts the list of strings into a list of Class types. The Class type as well as other types representing the different nodes in an AST are located in the AST_nodes.hs file. These types form a tree structure with the Class type at the root. A Class type can either be inheriting or non-inheriting, but because all classes inherit from Object the only Class in the non-inheriting category is the Object class. Each class also has a list of features, which can be either attributes or methods, and a feature can contain expressions and formals. These types are all populated with what was read in from the AST such as what class is inherited and line number information. Not being able to use a global variable for deserializing the list of strings made my code more complicated then I planned for, which was a downside of using Haskell for this assignment.

	The code for type checking everything but expressions is located in the Check_misc.hs file. For example one check was to look for inheritance cycles, which was done by walking up the inheritance tree for each class until I either reached the Object class or a class was revisted, which would indicate an inheritance cycle. The code for type checking expressions is in Type_checker.hs file. The tree representation of the AST was helpful when doing this type checking because it made it easy to write recursive type checking functions. Type checking an expression would take in the expression as well as other environment variables such as the object map. The function for type checking expressions will either return the type of the expression or an error string if the check was unsuccessful. The type returned is stored in the AST node and used for annotating the AST later on. The rules for type checking expressions were laid out in the Cool reference manual, for example the rule for type checking a “new” expression would be to return the type indicated in the expression. Type checking conditionals such as case statements were more difficult because the return type is a type union over all of the branches. The type union of two classes was implemented by moving up the class hierarchy of one type until it reached a point where it was a parent of the second type. Doing a type union over a list of types was done by folding this union operation over the list. Finally, one of the most difficult expressions to typecheck were dispatch expressions. There were three types of dispatch expressions to check, dynamic, static, and self. After the type of dispatch and the class being dispatched on were determined the proper method definition needed to be retrieved from the class environment. To ensure that the correct version of the method being dispatched was chosen, all of the inherited methods and attributes were added to each class before the type checking began. This ensured the correct method could be found by looking up the type and extracting the method definition from it's list of features. After extracting the method, the number of parameters and their types were checked to match up with the function definition, and the type of the entire expression would be the return type of the method. Otherwise an error string would be returned if an error occurred.

	I tested my semantic analyzer on all of the cool code I had available as well as new testcases I wrote myself. PA4t was very helpful for generating a wide range of testcases, especially negative testcases. The good.cl file is one example of a positive testcase I used. This testcase includes some different corner cases that were important to test, such as multiple inheritance hierarchies, the use of self and SELF_TYPE, conditionals, dispatch, and others. This testcase also included an inherit from Object, which was important for me to test because an explicit inherit from Object is treated differently then an implicit inherit from Object when serializing the different maps. The negative testcases were far more numerous then the positive testcases because there were more corner cases to account for. bad1.cl tests a dynamic dispatch on a method that returns SELF_TYPE. The return type of this expression is class Ccc, which does not conform to the expected return type of SELF_TYPE(Ccc). Having many checks for SELF_TYPE and comparing SELF_TYPE to other types was important because SELF_TYPE is a difficult concept to understand. bad2.cl is a negative testcase that checks for proper checking of a case statement. The return type of the case statement is the type union of all the branches which is Object, which does not conform to the expected return type of String. Finally, bad3.cl checks that the parameters in a dispatch conform to the method definition. The method in question is passed in a parameter of type Aaa where a type of Bbb is expected. Aaa is a parent of Bbb so it can not be used in its place, so there is a type error.